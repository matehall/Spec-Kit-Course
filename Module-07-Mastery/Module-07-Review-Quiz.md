# Module 7 Review Quiz: Mastery

**Module 7: Mastery**  
**Date:** November 29, 2025  
**Questions:** 20

---

## Instructions

This quiz covers Lessons 23-25, focusing on user-centric development, iterative processes, and the future of spec-driven development. Answer all questions, then check your answers at the end.

**Passing Score:** 16/20 (80%)

---

## Questions

### User-Centric Development (Lesson 23)

**1. What does "user-centric development" mean in the context of specifications?**

A) Writing specs that users can read  
B) Having users write the specifications  
C) Grounding specifications in user needs and validating with users  
D) Using user interface designs as specifications  

---

**2. According to WCAG 2.1, what are the four main principles of accessibility?**

A) Simple, Clear, Consistent, Testable  
B) Perceivable, Operable, Understandable, Robust  
C) Visual, Auditory, Motor, Cognitive  
D) Mobile, Desktop, Tablet, Screen Reader  

---

**3. What is the "Persona Spectrum" concept from Microsoft's Inclusive Design?**

A) Different personality types of users  
B) Permanent, temporary, and situational limitations  
C) User demographics by age  
D) Spectrum from novice to expert users  

---

**4. When should user testing occur in the spec workflow?**

A) Only after implementation is complete  
B) Only before writing specifications  
C) At multiple stages: problem validation, solution validation, usability testing, and post-release monitoring  
D) Never; specifications are sufficient  

---

**5. What is the Jobs-to-Be-Done (JTBD) framework used for?**

A) Creating job descriptions for developers  
B) Translating user needs into functional requirements  
C) Scheduling development tasks  
D) Organizing team workflows  

---

### Iterative & Creative Processes (Lesson 24)

**6. What is an "Experiment Specification"?**

A) A spec for testing environments  
B) A lightweight spec for exploring uncertain or risky ideas with clear hypotheses and success criteria  
C) A spec written by the QA team  
D) A formal specification with proofs  

---

**7. What is the purpose of a "Spike" in development?**

A) To fix urgent bugs  
B) To quickly explore and compare multiple technical approaches  
C) To increase team velocity  
D) To test security vulnerabilities  

---

**8. In the Strangler Fig migration pattern, what is the strategy?**

A) Delete all legacy code and rewrite from scratch  
B) Gradually replace legacy system components while keeping the system running  
C) Create a parallel system and switch over in one big cutover  
D) Stop all new development until migration is complete  

---

**9. What should you do when you discover a fundamental flaw in your specifications midway through implementation?**

A) Continue anyway; specs are contracts  
B) Update the specs to reflect new understanding; specs document current best knowledge  
C) Abandon the project  
D) Blame the person who wrote the spec  

---

**10. What is "continuous improvement" in the context of Spec Kit?**

A) Always adding new features  
B) Regular small enhancements tracked with lightweight improvement specs  
C) Refactoring all code every sprint  
D) Constantly changing specifications  

---

### Future of Spec-Driven Development (Lesson 25)

**11. What defines "AI-Native Development"?**

A) Using AI to write documentation  
B) Specifications as primary artifacts with AI handling most implementation  
C) Replacing all developers with AI  
D) Using AI for code reviews only  

---

**12. What is the primary human role in AI-native development?**

A) Writing code by hand  
B) Managing AI systems  
C) Design, architecture, validation, and problem identification  
D) Testing AI-generated code manually  

---

**13. What is "multi-agent development"?**

A) Multiple developers working on the same code  
B) Specialized AI agents (architect, backend, frontend, test) collaborating on implementation  
C) Using multiple AI models simultaneously  
D) Distributed team development  

---

**14. In formal verification with AI, what is the goal?**

A) Verifying AI models are accurate  
B) Using AI to generate provably correct code from formal specifications  
C) Proving that specifications are complete  
D) Verifying user requirements  

---

**15. What is "specification drift" monitoring in the future vision?**

A) Tracking when specifications move to different folders  
B) Automated detection when code behavior diverges from specifications  
C) Monitoring AI model performance  
D) Tracking team velocity over time  

---

### Integrated Mastery Questions

**16. You're building a feature for users with visual impairments. Which approach best embodies user-centric, spec-driven development?**

A) Build the feature first, add accessibility later  
B) Write specs with accessibility requirements, validate with screen reader users before and after implementation  
C) Use an accessibility checklist after implementation  
D) Let the AI handle accessibility automatically  

---

**17. Your team wants to try two different architectural approaches for a complex feature. What's the best Spec Kit workflow?**

A) Debate in meetings until consensus is reached  
B) Let the senior developer decide  
C) Create spike specs for both approaches, implement lightweight versions, compare with decision matrix  
D) Implement both fully and A/B test with users  

---

**18. You're migrating from a monolithic PHP app to microservices. How should specifications evolve?**

A) Archive all PHP specs and write new ones for microservices  
B) Keep behavior specs language-agnostic, create new implementation plans for each microservice  
C) Don't use specs during migration (too complex)  
D) Write separate specs for each programming language  

---

**19. An AI agent generates code that compiles but fails tests. What's the most likely cause?**

A) The AI is broken  
B) The specification has ambiguities, conflicts, or insufficient detail  
C) The tests are wrong  
D) The programming language is too complex  

---

**20. In 10 years, what skill will likely be MOST valuable for software developers?**

A) Writing code in 20 programming languages  
B) Understanding algorithms and data structures deeply  
C) Translating user needs into clear specifications and validating solutions  
D) Managing servers and infrastructure  

---

## Answer Key

<details>
<summary><strong>Click to Reveal Answers</strong></summary>

1. **C** - User-centric means grounding specs in user needs and validating with users
2. **B** - The four WCAG principles: Perceivable, Operable, Understandable, Robust
3. **B** - Persona Spectrum: permanent, temporary, and situational limitations
4. **C** - User testing should occur at multiple stages throughout the process
5. **B** - JTBD translates user needs into functional requirements
6. **B** - Experiment specs are lightweight specs for exploration with hypotheses
7. **B** - Spikes quickly explore and compare technical approaches
8. **B** - Strangler Fig gradually replaces components while system runs
9. **B** - Update specs when understanding changes; specs document current knowledge
10. **B** - Continuous improvement: regular small enhancements tracked with specs
11. **B** - AI-Native: specs as primary artifacts, AI handles implementation
12. **C** - Human role: design, architecture, validation, problem identification
13. **B** - Multi-agent: specialized AI agents collaborating on implementation
14. **B** - Formal verification: AI generates provably correct code from formal specs
15. **B** - Spec drift monitoring: detecting when code diverges from specifications
16. **B** - Write specs with accessibility requirements, validate with target users
17. **C** - Create spike specs, implement lightweight versions, compare systematically
18. **B** - Keep behavior specs language-agnostic, create new implementation plans
19. **B** - Most likely cause: spec has ambiguities, conflicts, or insufficient detail
20. **C** - Most valuable skill: translating user needs to specs and validating solutions

</details>

---

## Scoring Guide

**18-20 correct:** Excellent! You've achieved mastery.  
**16-17 correct:** Good understanding. Review any missed questions.  
**14-15 correct:** Passing. Consider reviewing the lessons for deeper understanding.  
**Below 14:** Review Module 7 lessons and retake the quiz.

---

## Detailed Explanations

<details>
<summary><strong>Question 2 Explanation</strong></summary>

**Correct Answer: B**

The four WCAG 2.1 principles (POUR):

1. **Perceivable:** Information and UI components must be presentable to users in ways they can perceive
   - Text alternatives for non-text content
   - Captions for media
   - Adaptable layouts
   - Sufficient color contrast

2. **Operable:** UI components and navigation must be operable
   - Keyboard accessible
   - Enough time to interact
   - No seizure-inducing content
   - Navigable structure

3. **Understandable:** Information and operation of UI must be understandable
   - Readable text
   - Predictable behavior
   - Input assistance and error prevention

4. **Robust:** Content must be robust enough to be interpreted by a wide variety of user agents, including assistive technologies
   - Compatible with assistive tech
   - Valid semantic HTML
   - ARIA labels where needed

These principles form the foundation of accessible design and should be embedded in specifications from the start.
</details>

<details>
<summary><strong>Question 6 Explanation</strong></summary>

**Correct Answer: B**

An experiment specification is a lightweight spec used for:

**Characteristics:**
- Clear hypothesis statement
- Minimal scope (smallest thing to learn)
- Measurable success criteria
- Time-boxed (e.g., 3 days, 1 week)
- Learning goals (what we're trying to discover)

**Purpose:**
- Explore risky or uncertain ideas
- Test assumptions before committing to full implementation
- Compare multiple approaches quickly
- Learn and iterate

**Not the same as:**
- Full production specifications (too heavy for experiments)
- Test plans (experiments are about discovery, not validation of known requirements)
- Prototypes (experiment specs guide prototype creation)

**Example Use Cases:**
- "We think users want feature X" ‚Üí Experiment to validate
- "Not sure if architecture Y will scale" ‚Üí Spike to test
- "AI-powered search might improve UX" ‚Üí Experiment to measure

Key insight: Experiments embrace uncertainty. Full specs assume clarity. Use the right tool for the situation.
</details>

<details>
<summary><strong>Question 8 Explanation</strong></summary>

**Correct Answer: B**

The Strangler Fig Pattern (named after strangler fig vines that grow around trees):

**Strategy:**
1. Identify boundaries in legacy system
2. Build new system components alongside legacy
3. Gradually route traffic from legacy to new
4. Eventually "strangle" the legacy system (decommission once fully replaced)

**Why This Works:**
- System stays running (no downtime)
- Incremental migration (lower risk)
- Can roll back if issues arise
- Learn as you go

**Alternatives and Why They're Riskier:**
- **Big Bang Rewrite:** Replace everything at once
  - Risk: High (everything breaks if something goes wrong)
  - Downtime: Significant
  - Rollback: Difficult

- **Parallel Run:** Build new system, run both simultaneously
  - Risk: Medium (maintaining two systems is expensive)
  - Cost: High (double infrastructure)
  - Duration: Fixed cutover date creates pressure

**Spec Kit's Role in Strangler Fig:**
- Migration specs track which components are migrated
- Behavior specs ensure new system matches legacy
- Testing specs validate equivalence
- Rollback specs document safety procedures

The Strangler Fig pattern is ideal for enterprise migrations where risk and downtime must be minimized.
</details>

<details>
<summary><strong>Question 11 Explanation</strong></summary>

**Correct Answer: B**

AI-Native Development characteristics:

**What It IS:**
- Specifications are the primary development artifact (not code)
- AI handles most implementation from specs
- Humans focus on design, architecture, validation
- Rapid iteration: change spec ‚Üí regenerate code
- Quality through comprehensive validation (tests, reviews)

**What It's NOT:**
- Replacing developers (humans still essential for design and judgment)
- Using AI only for documentation (that's AI-assisted, not AI-native)
- Letting AI make all decisions (humans define what to build)
- Code reviews only (humans also design systems)

**The Workflow:**
```
1. Human: Define problem, user needs
2. Human: Write specification
3. AI: Generate implementation from spec
4. Human: Validate (tests, review, user testing)
5. Human: Refine spec based on learnings
6. Repeat until correct
```

**Key Insight:**
AI-native doesn't mean "AI does everything." It means **the primary artifact shifts from code to specifications**, and AI becomes the implementation partner, not just an assistant.

Humans are MORE important in AI-native development, not less‚Äîbut the role shifts from implementer to designer/validator.
</details>

<details>
<summary><strong>Question 16 Explanation</strong></summary>

**Correct Answer: B**

This question integrates user-centric development with spec-driven workflow:

**Why B is Correct:**

1. **Accessibility in Specs (Not Afterthought):**
   ```markdown
   ## Feature Spec: Dashboard

   ### Accessibility Requirements (WCAG AA)
   - Screen reader: All content announced in logical order
   - Keyboard navigation: All functions accessible via keyboard
   - High contrast: Color contrast ratio ‚â• 4.5:1
   - Focus indicators: Visible focus on all interactive elements
   
   ### Testing with Target Users:
   - Pre-implementation: Test wireframes/prototype with 3 screen reader users
   - Post-implementation: Validate with 5 screen reader users
   - Success criteria: 85%+ task completion, no critical barriers
   ```

2. **User Validation:**
   - **Before implementation:** Test designs/prototypes with users who will actually use assistive tech
   - **After implementation:** Validate that implementation matches design intent
   - Don't assume‚Äîvalidate with real users

3. **Iterative Refinement:**
   - Users find issues ‚Üí refine spec ‚Üí re-implement ‚Üí re-validate
   - Accessibility isn't one-and-done; it's continuous

**Why Other Options Are Wrong:**

- **A (Build first, add accessibility later):**
  - Retrofitting is 3-5x more expensive
  - Often impossible without significant refactoring
  - Creates technical debt
  - Legal/ethical issues shipping inaccessible product

- **C (Checklist after implementation):**
  - Better than nothing, but reactive
  - May discover unfixable issues
  - No user validation (checklist ‚â† usability)

- **D (Let AI handle it):**
  - AI can help, but can't replace human validation
  - AI doesn't experience disabilities
  - Accessibility requires judgment, not just compliance

**The Principle:** Accessibility must be:
1. Specified from the start (in specs)
2. Validated with target users (before and after)
3. Integrated into the process (not bolted on)

This is user-centric, spec-driven development at its best.
</details>

<details>
<summary><strong>Question 20 Explanation</strong></summary>

**Correct Answer: C**

Let's analyze each option:

**A: Writing code in 20 programming languages**
- **Why not:** AI can translate between languages
- **Future value:** Low (AI handles syntax)
- **Human advantage:** None (AI is better at syntax)

**B: Understanding algorithms and data structures deeply**
- **Why valuable:** Important for evaluating AI's choices
- **Future value:** Medium (still useful for judgment)
- **Limitation:** AI can implement any algorithm you describe

**C: Translating user needs into clear specifications and validating solutions**
- **Why MOST valuable:** AI can't identify what problems to solve
- **Future value:** High (AI amplifies this skill)
- **Human advantage:** Irreplaceable
- **Components:**
  - Empathy: Understanding user needs and pain points
  - Communication: Extracting requirements from stakeholders
  - Judgment: Evaluating if a solution actually solves the problem
  - Creativity: Designing novel solutions
  - Validation: Determining if implementation meets real needs

**D: Managing servers and infrastructure**
- **Why not:** Increasingly automated (IaC, serverless, managed services)
- **Future value:** Low (commodity skill)

**The Reasoning:**

As AI handles more implementation:

**Value DECREASES for:**
- Syntax knowledge
- Language-specific expertise
- Boilerplate code writing
- Manual testing
- Infrastructure management (being automated)

**Value INCREASES for:**
- Understanding user needs (AI can't do this)
- Problem identification (AI can't prioritize what to build)
- Specification clarity (garbage in ‚Üí garbage out)
- Solution validation (does this actually solve the problem?)
- Architectural judgment (trade-offs, non-functional requirements)
- Ethical considerations (bias, privacy, societal impact)

**The Core Insight:**

"Writing code" is becoming a commodity (AI can do it).

"Deciding what code to write and why" is becoming the scarce skill.

Specification-writing is the interface between human intent and machine implementation. As AI gets better at implementation, specifications become more critical, not less.

**Your career future depends on mastering:**
1. Understanding users and problems deeply
2. Translating that understanding into clear specifications
3. Validating that solutions actually work for users

These skills are AI-resistant because they require:
- Human empathy (AI doesn't experience user pain)
- Contextual judgment (AI lacks real-world context)
- Creative problem-solving (AI interpolates; humans extrapolate)
- Ethical reasoning (AI has no values)

**This is why this course matters:** It prepares you for a future where specifications, not code, are the primary artifact.
</details>

---

## Reflection Questions

After completing this quiz, reflect on:

1. **User-Centricity:**
   - How user-focused are your current specifications?
   - What changes would make them more user-centric?

2. **Iteration & Creativity:**
   - Do you embrace experimentation in your process?
   - How could experiment specs improve your workflow?

3. **The Future:**
   - How ready are you for AI-native development?
   - What skills do you need to develop?

4. **Your Journey:**
   - What's your next step in mastering spec-driven development?
   - How will you contribute to the community?

---

## Final Course Reflection

You've completed all 25 lessons. Consider:

**What You've Learned:**
- Spec-driven development philosophy and practice
- Spec Kit workflow and tools
- AI agent integration
- Enterprise adoption strategies
- User-centric design
- Iterative and creative processes
- The future of the field

**How You'll Apply It:**
- What's the first project you'll apply Spec Kit to?
- Who will you teach?
- How will you contribute to the community?

**Your Commitment:**
- What's your 30-day action plan?
- What's your 12-month roadmap?
- How will you measure your progress?

---

## Next Steps

**Immediate:**
- [ ] Complete final reflection
- [ ] Start capstone project
- [ ] Join Spec Kit community

**This Month:**
- [ ] Apply Spec Kit to real project
- [ ] Share learnings (blog post, talk, etc.)
- [ ] Make first contribution to Spec Kit

**This Year:**
- [ ] Master advanced techniques
- [ ] Lead adoption in your team/org
- [ ] Mentor others
- [ ] Contribute significantly to the field

---

## Congratulations! üéâ

You've completed the Spec Kit Course and achieved mastery. You're now equipped to:
- Build software spec-first
- Integrate AI effectively
- Adopt enterprise-wide
- Lead teams
- Contribute to the field

**Welcome to the community of spec-driven practitioners.**

**Now go build the future.** üöÄ

---

## Navigation

‚Üê [Previous: Lesson 25 - Future of Spec-Driven Development](Lesson-25-Future-of-Spec-Driven-Development.md)  
‚Üí [Next: Final Capstone Project](Final-Capstone-Project.md)  
‚Üë [Back to Module 7](../Module-07-Mastery/)  
üè† [Course Home](../00-Course-Overview.md)
